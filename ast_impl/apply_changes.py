"""
Apply the script modifications generated by LLMs.
"""

import json
import os
import re
from argparse import ArgumentParser

from tqdm import tqdm

from ast_impl import add_node_at_line, ast, delete_node_at_line


def parse_modifications(modifications_str):
    modifications = []
    tag_patterns = re.findall(r"<(.*?)>(.*?)</(.*?)>", modifications_str, flags=re.DOTALL)

    for tag in tag_patterns:
        if tag[0] != tag[2]:  # both should be tag names
            raise RuntimeError(f"Tag mismatch: {tag[0]} != {tag[2]}")

        tag_name = tag[0]
        tag_value = tag[1]

        if tag_name == "action":
            modifications.append({"action": tag_value})
        else:
            if not modifications:
                # no action added, can't construct modification without an action defined first
                continue
            modifications[-1][tag_name] = tag_value

    return modifications


def apply_changes(script, modifications):
    if not modifications:
        raise RuntimeError("No modifications. Skipping.")

    if modifications == "size_limit_4000" or modifications == "error":
        raise RuntimeError("Error generating modifications. Skipping.")

    try:
        script_tree = ast.parse(script)
    except:
        raise RuntimeError("Unable to parse script as AST")
    modifications = sorted(modifications, key=lambda v: int(v["line"]) if "line" in v else int(v["end_line"]))[::-1]
    current_line = 999_999_999

    # sanity check
    for modification in modifications:
        if modification["action"] == "add":
            if current_line < int(modification["line"]):
                raise RuntimeError("Overlapping lines - add")
            current_line = int(modification["line"])
        elif modification["action"] == "delete":
            if current_line < int(modification["end_line"]):
                raise RuntimeError("Overlapping lines - delete")
            current_line = int(modification["start_line"])
        else:
            raise RuntimeError("Invalid action")

    for modification in modifications:
        if modification["action"] == "add":
            try:
                snippet = modification["snippet"].strip("\n")
                if snippet.startswith("\t"):
                    tab_indent = len(snippet) - len(snippet.lstrip("\t"))
                    non_indented_snippet = ""
                    for snippet_line in snippet.split("\n"):
                        non_indented_snippet += snippet_line[tab_indent:] + "\n"
                    modification["snippet"] = non_indented_snippet

                if snippet.startswith(" "):
                    space_indent = len(snippet) - len(snippet.lstrip(" "))
                    non_indented_snippet = ""
                    for snippet_line in snippet.split("\n"):
                        non_indented_snippet += snippet_line[space_indent:] + "\n"
                    modification["snippet"] = non_indented_snippet

                snippet_tree = ast.parse(modification["snippet"])
            except TabError:
                raise RuntimeError("Invalid snippet due to tabs.")
            script_tree = add_node_at_line(script_tree, snippet_tree, int(modification["line"]), before=True)

        elif modification["action"] == "delete":
            for line in range(int(modification["end_line"]), int(modification["start_line"]) - 1, -1):
                script_tree = delete_node_at_line(script_tree, line)
        else:
            raise RuntimeError("Invalid action")

    try:
        script = ast.unparse(script_tree)
    except ValueError:
        raise RuntimeError("Unable to unparse tree back to script.")

    return script


def main(dataset, model):
    modifications_json = json.load(open(f"{model}-adversarial-generation-results/{dataset}-{model}-modifications.json"))
    for filename, modifications_str in modifications_json.items():
        try:
            modifications = parse_modifications(modifications_str)
            modifications_json[filename] = modifications
        except:
            print("Failed parsing modifications.")
            continue

    output_dir = f"{model}-adversarial-generation-results/{dataset}-modified/"
    os.makedirs(output_dir, exist_ok=True)

    scripts_dir = f"open_source_data/{dataset}/"
    num_fails = 0
    for filename, modifications in tqdm(modifications_json.items()):
        script_content = open(os.path.join(scripts_dir, filename)).read()
        try:
            modified_script = apply_changes(script_content, modifications)
        except Exception as e:
            # print(repr(e))
            num_fails += 1
            continue
        with open(os.path.join(output_dir, filename), "w") as modified_script_file:
            modified_script_file.write(modified_script)

    print(f"Number of failed modifications: {num_fails}")


if __name__ == "__main__":
    parser = ArgumentParser()
    parser.add_argument("--dataset", type=str, help="Dataset for which to apply modifications.")
    parser.add_argument("--model", type=str, help="LLM which generated the modifications.")
    args = parser.parse_args()

    main(dataset=args.dataset, model=args.model)
